<template>
  <div class="flexcol legacy-track">
    <div class="legacy-track-header flexrow">
      <h4
        :data-tooltip="`IRONSWORN.LEGACY.${propKey.toUpperCase()}.Description`"
      >
        {{ title }}
      </h4>
      <p
        v-if="overflow"
        class="nogrow"
        style="padding: 1px; margin-right: 10px"
      >
        {{ overflow }}
      </p>
      <btn-faicon
        class="block nogrow"
        v-if="editMode"
        icon="caret-left"
        @click="decrease"
      />
      <btn-faicon class="block nogrow" icon="caret-right" @click="increase" />
    </div>

    <div class="flexrow track">
      <div
        class="flexcol track-box"
        v-for="(box, i) in boxes"
        :key="`box${i}`"
        v-html="box"
      ></div>
    </div>

    <xp-track :max="xpBoxCount" :marked="xpSpent" @click="setXp" />
  </div>
</template>

<style lang="less" scoped>
h4 {
  margin: 0.5rem 0;
}
.xp {
  max-height: 40px;
}
.legacy-track-header {
  align-items: center;
}
</style>

<script setup lang="ts">
import { computed, defineComponent, inject, Ref } from 'vue'
import { IronswornActor } from '../../actor/actor'
import { $ActorKey } from '../provisions'
import BtnFaicon from './buttons/btn-faicon.vue'
import XpTrack from './xp-track.vue'

function ticksSvg(ticks: number) {
  let ret = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">'
  if (ticks > 0) ret += '<line x1="23" y1="23" x2="77" y2="77" />'
  if (ticks > 1) ret += '<line x1="77" y1="23" x2="23" y2="77" />'
  if (ticks > 2) ret += '<line x1="15" y1="50" x2="85" y2="50" />'
  if (ticks > 3) ret += '<line x1="50" y1="15" x2="50" y2="85" />'
  return ret + '</svg>'
}

const props = defineProps<{ propKey: string; title: string }>()

const actor = inject('actor') as Ref
const $actor = inject($ActorKey)

const editMode = computed(() => {
  return actor.value.flags['foundry-ironsworn']?.['edit-mode']
})
const ticks = computed(() => {
  return actor.value.data.legacies[props.propKey] ?? 0
})
const xpBoxCount = computed(() => {
  // 2 for each box up until 10, then 1 for each box afterwards
  const fullBoxes = Math.floor(ticks.value / 4)
  if (fullBoxes <= 10) {
    return fullBoxes * 2
  } else {
    return fullBoxes + 10
  }
})
const xpArray = computed(() => {
  const ret = []
  for (let i = 1; i <= xpBoxCount.value; i++) {
    ret.push(i)
  }
  return ret
})
const xpSpent = computed(() => {
  return actor.value.data.legacies[`${props.propKey}XpSpent`] ?? 0
})
const overflow = computed(() => {
  const n = Math.floor(ticks.value / 40) * 10
  if (n > 0) {
    return `(+${n})`
  }
  return undefined
})
const boxes = computed(() => {
  const ret = [] as string[]
  let remainingTicks = ticks.value % 40
  for (let i = 0; i < 10; i++) {
    ret.push(ticksSvg(remainingTicks))
    remainingTicks -= 4
  }
  return ret
})

function adjust(inc) {
  const current = actor.value.data?.legacies[props.propKey] ?? 0
  $actor?.update({
    [`data.legacies.${props.propKey}`]: current + inc,
  })
}
function increase() {
  adjust(1)
}
function decrease() {
  adjust(-1)
}

function setXp(n) {
  $actor?.update({
    data: { legacies: { [`${props.propKey}XpSpent`]: n } },
  })
}
</script>
